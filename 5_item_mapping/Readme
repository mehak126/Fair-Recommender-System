The code item_mapping.py reads the input data logs file (merge_11col.csv) and for each unique item in the logs creates a feature vector consisting of:
1. Rating (9th column) - this forms the first feature
2. A vector representing which all aspects the item belongs to. e.g- the topic mdd has 5 aspects. The next 5 features of the item will correspond to each of these aspects with a 0 if the item does not belong to that aspect and a 1 if it belongs.
3. Context intensity from each cluster. e.g- if there are 5 user clusters, the next 5 features will correspond to the context intensity from each cluster respectively. For calculating the context intensity, first we obtain the preference vector of the contributor of the item. This will only be present if the contributor was a super user initially. If the contributor was not a super user, we set his/her preference vector to be all 0s (neutral preference). Then, the distance of the contributor's vector is calculated from each clusters averaged preference vector and that is set to be the corresponding feature vector.


As aspects (obtained from the campaign categories column) are part of the features, the code is topic (theme) specific. Also for each theme, we are not just considering all aspects as it is, we are selecting and merging some aspects as well. Hence different parts of the code will have to be commented/uncommented when running the code for a specific topic. e.g.- the topic mdd has 12 possible aspects, stored in the list 'mdd' in line 20. However, after deleting and merging irrelevent aspects, we only need 5 of them whose names are stored in the list 'mdd_eff' in line 30. We first create a dictionary mdd_dict for the aspects in mdd_eff, mapping each aspect to a unique number (lines 56-57). Then, the aspects which had to be merged are assigned the index of the aspect with which it had to be merged (lines 62-67). Since the aspect names and selected/merged aspects are different for each topic, these cases had to be handled seperately. 